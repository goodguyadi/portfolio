[
  {
  "title": "Setting up my Home Cyber-Security Lab",
  "date": "2025-06-10",
  "excerpt": "VirtualBox, Wireshark and Snort helped me practise basic defence.",
  "content": "<h3>Goal</h3><p>Create a safe, isolated lab where I can learn network-security tools without risking my main PC.</p><h3>1. Hardware</h3><ul><li>Old desktop with 16&nbsp;GB RAM &nbsp;•&nbsp; 500&nbsp;GB SSD</li><li>Cheap unmanaged switch for physical segmentation</li></ul><h3>2. Virtualisation</h3><p>I installed VirtualBox and spun up:</p><ul><li><strong>Kali Linux</strong> – attacker box</li><li><strong>Ubuntu Server</strong> – target VM (Apache + OpenSSH)</li><li><strong>pfSense</strong> – acts as an internal firewall/router</li></ul><h3>3. Monitoring tools</h3><p><strong>Wireshark</strong> for packet capture and <strong>Snort</strong> for IDS alerts. Both run in their own VM so logs stay separate from the targets.</p><h3>4. First exercise</h3><p>Scanned Ubuntu with <code>nmap -sV</code>, then wrote a Snort rule to alert on SSH brute-force attempts.</p><h3>5. Lessons learned</h3><ol><li>Snapshots are lifesavers when you mis-configure pfSense.</li><li>Virtual networks let you practise dangerous tools safely.</li><li>Logging everything makes post-exercise analysis much easier.</li></ol>"
},
{
  "title": "Why I switched to CSS variables",
  "date": "2025-07-25",
  "excerpt": "They power my new light/dark toggle and simplify theming.",
  "content": "<h3>Problem</h3><p>My old stylesheet hard-coded colours everywhere. Adding a dark mode meant duplicating rules with new hex values.</p><h3>Solution: CSS custom properties</h3><pre><code>:root {\n  --bg: #ffffff;\n  --text: #212529;\n}\nbody.dark {\n  --bg: #212529;\n  --text: #e9ecef;\n}</code></pre><p>Components now reference <code>var(--bg)</code> and <code>var(--text)</code>. Switching themes = toggling one class.</p><h3>Benefits</h3><ul><li><strong>Simplicity&nbsp;</strong>— only two colour definitions to maintain.</li><li><strong>Runtime updates&nbsp;</strong>— JavaScript can change a variable value without re-parsing the stylesheet.</li><li><strong>Themes as JSON&nbsp;</strong>— future idea: fetch a palette and update variables on the fly.</li></ul><h3>Takeaway</h3><p>Custom properties turned a messy colour overhaul into a 15-minute refactor and enabled the site-wide light/dark mode.</p>"
}
,
  {
  "title": "Inside the Light/Dark Theme Switcher",
  "date": "2025-07-29",
  "excerpt": "Design decisions, code snippets, accessibility and future ideas.",
  "content": "<h2>1&nbsp;·&nbsp;Why a theme switcher?</h2><p>Many visitors prefer dark UIs, others want light. Instead of maintaining two full stylesheets I used <strong>CSS custom properties</strong> plus a tiny script.</p><h2>2&nbsp;·&nbsp;Key files</h2><pre><code>style.css      → declares --bg, --text, etc.\nheader.html    → contains &lt;button id=\"themeToggle\"&gt;\ntheme.js       → toggles .dark + saves choice</code></pre><h2>3&nbsp;·&nbsp;Core JavaScript</h2><pre><code>// theme.js (excerpt)\nconst saved   = localStorage.getItem('theme');\nconst prefers = window.matchMedia('(prefers-color-scheme: dark)').matches;\nconst dark    = saved === 'dark' || (!saved && prefers);\n\ndocument.body.classList.toggle('dark', dark);\n\ndocument.addEventListener('click', (e) =&gt; {\n  const btn = e.target.closest('#themeToggle');\n  if (!btn) return;\n  const isDark = document.body.classList.toggle('dark');\n  btn.textContent = isDark ? 'Light mode' : 'Dark mode';\n  localStorage.setItem('theme', isDark ? 'dark' : 'light');\n});</code></pre><h2>4&nbsp;·&nbsp;Gotchas &amp; fixes</h2><ul><li><strong>Navbar rebuild</strong> – Bootstrap replaces the toggle on resize. I solved this with event-delegation (<code>document.addEventListener('click', …)</code>).</li><li><strong>Header injection timing</strong> – the script waits for a custom <code>layoutReady</code> event fired by <code>inject-layout.js</code>.</li></ul><h2>5&nbsp;·&nbsp;Accessibility checks</h2><ol><li>Added <code>aria-pressed</code> attribute that flips with the theme.</li><li>Lighthouse score: <em>Contrast 90 / 100</em> in both themes.</li></ol><h2>6&nbsp;·&nbsp;Future roadmap</h2><ul><li>Auto-sync with system setting changes in real time (<code>matchMedia</code> listener).</li><li>Animated colour transition using <code>prefers-reduced-motion</code> fallback.</li></ul>"
},
{
  "title": "Building a JSON-Powered Blog with Fetch",
  "date": "2025-07-29",
  "excerpt": "Separating content from layout using a single posts.json file.",
  "content": "<h2>1&nbsp;·&nbsp;Project goals</h2><p>I wanted to add blog posts without editing HTML every time. The solution: <strong>one JSON file</strong> plus a 40-line script that turns each object into a Bootstrap card.</p><h2>2&nbsp;·&nbsp;Data structure</h2><pre><code>posts.json\n[\n  {\n    \"title\": \"...\",\n    \"date\":  \"YYYY-MM-DD\",\n    \"excerpt\": \"Short intro\",\n    \"content\": \"&lt;h2&gt;Full HTML...&lt;/h2&gt;\"\n  }\n]</code></pre><h2>3&nbsp;·&nbsp;Render pipeline</h2><pre><code>// scripts.js (excerpt)\nfetch('posts.json')\n  .then(r =&gt; r.json())\n  .then(posts =&gt; posts.forEach(buildCard))\n  .catch(err =&gt; showError(err));</code></pre><p><code>buildCard()</code> creates <code>&lt;div class=\"card\"&gt;</code> elements, injects them into <code>#blog-list</code> and wires a Read more / Show less toggle.</p><h2>4&nbsp;·&nbsp;Gotchas &amp; fixes</h2><ul><li><strong>CORS block on file:///</strong> – fetch fails if the page isn’t served over HTTP, so testing is done via VS Code Live Server.</li><li><strong>Markdown vs HTML</strong> – I ditched Markdown and store ready-made HTML to keep payload small and remove the extra parser.</li></ul><h2>5&nbsp;·&nbsp;Testing</h2><p>I used the browser Network panel to confirm a single GET for <code>posts.json</code> and Lighthouse to ensure no console errors.</p><h2>6&nbsp;·&nbsp;Future features</h2><ul><li>Client-side pagination for >10 posts.</li><li>Tag filter buttons (simple array <code>includes</code> check).</li><li>CI job that lints the JSON on every push.</li></ul>"
}


]
